rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // SECURITY CONSTANTS
    // ============================================
    // These limits should match Zod schema MAX_LENGTHS
    // SHORT: 100, MEDIUM: 255, LONG: 1000, TEXT: 5000

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }

    // Cache user document for the entire request (CRITICAL: only 1 read per request!)
    // This is called once and the result is reused throughout the request
    function userDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // Get user data from cached document
    function userData() {
      return userDoc().data;
    }

    // Check if user exists using cached document
    function userExists() {
      return userDoc() != null;
    }

    // Check if user status is ACTIVE
    function isActiveUser() {
      return isSignedIn() && userExists() && userData().status == 'active';
    }

    // Get user's role
    function getUserRole() {
      return userData().role;
    }

    // Role hierarchy: view=1, edit=2, admin=3, super_admin=4
    function getRoleLevel(role) {
      return role == 'super_admin' ? 4 :
             role == 'admin' ? 3 :
             role == 'edit' ? 2 :
             role == 'view' ? 1 : 0;
    }

    // Check if user has minimum required role level
    function hasMinimumRole(requiredRole) {
      return isActiveUser() && getRoleLevel(getUserRole()) >= getRoleLevel(requiredRole);
    }

    // Check if user can read (VIEW role or higher)
    function canRead() {
      return hasMinimumRole('view');
    }

    // Check if user can write (EDIT role or higher)
    function canWrite() {
      return hasMinimumRole('edit');
    }

    // Check if user is ADMIN or higher
    function isAdmin() {
      return hasMinimumRole('admin');
    }

    // Check if user is SUPER_ADMIN
    function isSuperAdmin() {
      return isActiveUser() && getUserRole() == 'super_admin';
    }

    // Check if role change is valid (target user must have lower role than current user)
    function canManageUserRole(targetRole) {
      return getRoleLevel(getUserRole()) > getRoleLevel(targetRole);
    }


    // ============================================
    // MEMBERS COLLECTION
    // ============================================

    match /members/{memberId} {
      // Anyone with VIEW role can read members
      allow read: if canRead();

      // EDIT role or higher can create members
      allow create: if canWrite() &&
                      isValidMemberData(request.resource.data) &&
                      hasRequiredMemberFields(request.resource.data);

      // EDIT role or higher can update members
      // Note: Relaxed validation for updates - only checks write permission
      // Full validation on create, partial updates allowed here
      allow update: if canWrite();

      // EDIT role or higher can delete members
      allow delete: if canWrite();

      // Validate member data structure with length limits (match Zod schemas)
      // Note: comments array is optional and validated separately
      function isValidMemberData(data) {
        return data.fullName is string && data.fullName.size() > 0 && data.fullName.size() <= 100 &&
               data.email is string && data.email.size() <= 255 &&
               data.phone is string && data.phone.size() <= 20 &&
               data.address is string && data.address.size() <= 500 &&
               data.dateOfBirth is string && data.dateOfBirth.size() <= 10 &&
               data.golfAustraliaId is string && data.golfAustraliaId.size() <= 20 &&
               data.membershipCategory is string && data.membershipCategory.size() <= 50 &&
               data.accountBalance is number && data.accountBalance >= -1000000 && data.accountBalance <= 1000000 &&
               data.status in ['active', 'inactive'] &&
               data.dateJoined is string && data.dateJoined.size() <= 10 &&
               data.emergencyContact is string && data.emergencyContact.size() <= 255 &&
               // comments is optional - if present must be a list
               (!('comments' in data.keys()) || data.comments is list);
      }

      // Validate timestamps (allows serverTimestamp() sentinel values)
      function hasValidTimestamps(data) {
        return (data.createdAt is timestamp || !('createdAt' in data.keys())) &&
               (data.updatedAt is timestamp || !('updatedAt' in data.keys()));
      }

      function hasRequiredMemberFields(data) {
        return data.keys().hasAll(['fullName', 'email', 'phone', 'address',
                                   'dateOfBirth', 'golfAustraliaId', 'membershipCategory',
                                   'accountBalance', 'status', 'dateJoined',
                                   'emergencyContact']);
        // Note: createdAt and updatedAt are validated separately to allow serverTimestamp()
      }
    }


    // ============================================
    // PAYMENTS COLLECTION
    // ============================================

    match /payments/{paymentId} {
      // Anyone with VIEW role can read payments
      allow read: if canRead();

      // EDIT role or higher can create payments
      allow create: if canWrite() &&
                      isValidPaymentData(request.resource.data) &&
                      hasRequiredPaymentFields(request.resource.data) &&
                      request.resource.data.recordedBy == request.auth.uid;

      // EDIT role or higher can update payments
      // Can only update if they recorded it, or if they're ADMIN+
      allow update: if canWrite() &&
                      isValidPaymentData(request.resource.data) &&
                      (resource.data.recordedBy == request.auth.uid || isAdmin());

      // EDIT role or higher can delete payments
      allow delete: if canWrite();

      // Validate payment data structure with length limits (match Zod schemas)
      function isValidPaymentData(data) {
        return data.memberId is string && data.memberId.size() > 0 && data.memberId.size() <= 128 &&
               data.memberName is string && data.memberName.size() > 0 && data.memberName.size() <= 100 &&
               data.amount is number && data.amount > 0 && data.amount <= 1000000 &&
               data.paymentDate is string && data.paymentDate.size() <= 10 &&
               data.paymentMethod in ['bank_transfer', 'cash', 'cheque', 'card'] &&
               data.reference is string && data.reference.size() <= 100 &&
               data.notes is string && data.notes.size() <= 1000 &&
               data.receiptNumber is string && data.receiptNumber.size() > 0 && data.receiptNumber.size() <= 20 &&
               data.recordedBy is string && data.recordedBy.size() > 0 && data.recordedBy.size() <= 128;
      }

      function hasRequiredPaymentFields(data) {
        return data.keys().hasAll(['memberId', 'memberName', 'amount', 'paymentDate',
                                   'paymentMethod', 'reference', 'notes', 'receiptNumber',
                                   'recordedBy']);
        // Note: createdAt and updatedAt are validated separately to allow serverTimestamp()
      }
    }


    // ============================================
    // USERS COLLECTION
    // ============================================

    match /users/{userId} {
      // Users can read their own document
      // ADMIN+ can read all user documents
      allow read: if isSignedIn() && (request.auth.uid == userId || isAdmin());

      // Only allow creation during user registration
      // New users can only create with 'pending' status and 'view' role
      allow create: if isSignedIn() &&
                      request.auth.uid == userId &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.role == 'view' &&
                      isValidUserData(request.resource.data) &&
                      hasRequiredUserFields(request.resource.data);

      // ADMIN can update user status and roles
      // SUPER_ADMIN can update anyone (including other admins)
      // ADMIN cannot update SUPER_ADMIN users
      allow update: if isAdmin() &&
                      isValidUserData(request.resource.data) &&
                      // SUPER_ADMIN can update anyone
                      (isSuperAdmin() ||
                       // ADMIN can only update users with lower roles than their own
                       (canManageUserRole(resource.data.role) &&
                        canManageUserRole(request.resource.data.role)));

      // Only SUPER_ADMIN can delete users (hard delete)
      allow delete: if isSuperAdmin();

      // Validate user data structure with length limits
      // CRITICAL: Users cannot set their own role to admin/super_admin (enforced in create rule)
      function isValidUserData(data) {
        return data.email is string && data.email.size() > 0 && data.email.size() <= 255 &&
               data.role in ['view', 'edit', 'admin', 'super_admin'] &&
               data.status in ['pending', 'active', 'inactive'];
      }

      function hasRequiredUserFields(data) {
        return data.keys().hasAll(['email', 'role', 'status']);
        // Note: createdAt and updatedAt are validated separately to allow serverTimestamp()
      }
    }


    // ============================================
    // FEES COLLECTION
    // ============================================

    match /fees/{feeId} {
      // Anyone with VIEW role can read fees
      allow read: if canRead();

      // Only SUPER_ADMIN can create fees (via fee application)
      allow create: if isSuperAdmin() &&
                      isValidFeeData(request.resource.data);

      // Only SUPER_ADMIN can update or delete fees
      allow update, delete: if isSuperAdmin();

      // Validate fee data structure
      function isValidFeeData(data) {
        return data.memberId is string && data.memberId.size() > 0 &&
               data.memberName is string && data.memberName.size() > 0 &&
               data.feeYear is number && data.feeYear >= 2020 && data.feeYear <= 2030 &&
               data.categoryId is string && data.categoryId.size() > 0 &&
               data.categoryName is string && data.categoryName.size() > 0 &&
               data.amount is number && data.amount >= 0 &&
               data.appliedDate is string &&
               data.appliedBy is string && data.appliedBy.size() > 0 &&
               data.notes is string;
      }
    }


    // ============================================
    // MEMBERSHIP CATEGORIES COLLECTION
    // ============================================

    match /membershipCategories/{categoryId} {
      // Anyone with VIEW role can read categories
      allow read: if canRead();

      // Only SUPER_ADMIN can create, update, or delete categories
      allow create: if isSuperAdmin() &&
                      isValidCategoryData(request.resource.data);

      allow update: if isSuperAdmin() &&
                      isValidCategoryData(request.resource.data);

      allow delete: if isSuperAdmin();

      // Validate category data structure
      function isValidCategoryData(data) {
        return data.name is string && data.name.size() > 0 &&
               data.ageMin is number && data.ageMin >= 0 &&
               data.ageMax is number && data.ageMax >= 0 &&
               data.playingRights is string &&
               data.annualFee is number && data.annualFee >= 0 &&
               data.joiningFee is number && data.joiningFee >= 0 &&
               data.order is number &&
               data.isSpecial is bool;
      }
    }


    // ============================================
    // APPLICATIONS COLLECTION (PUBLIC SUBMISSION)
    // ============================================

    match /applications/{applicationId} {
      // PUBLIC CREATE - Anyone can submit an application (no auth required)
      // Strict validation prevents malicious data
      allow create: if isValidApplicationSubmission(request.resource.data) &&
                      hasRequiredApplicationFields(request.resource.data);

      // PUBLIC READ - For email verification only (no auth required)
      // Allow reading applications in 'submitted' or 'email_verified' status
      // This allows clicking verification link again to see success message
      allow read: if resource.data.status == 'submitted' ||
                     resource.data.status == 'email_verified';

      // PUBLIC UPDATE - For email verification only
      // Allows updating verification fields with valid token (no auth required)
      allow update: if isValidEmailVerification(resource.data, request.resource.data);

      // AUTHENTICATED READ - Only EDIT role or higher can view applications
      allow read: if canWrite();

      // AUTHENTICATED UPDATE - Only EDIT role or higher can approve/reject/edit
      // Must be email verified before admin can update
      allow update: if canWrite() &&
                      isValidAdminUpdate(resource.data, request.resource.data);

      // AUTHENTICATED DELETE - Only SUPER_ADMIN can delete applications
      allow delete: if isSuperAdmin();

      // ===== VALIDATION FUNCTIONS =====

      // Validate application submission (PUBLIC CREATE)
      function isValidApplicationSubmission(data) {
        return // Personal details
               data.title in ['Mr', 'Mrs', 'Miss', 'Ms'] &&
               data.fullName is string && data.fullName.size() > 0 && data.fullName.size() <= 100 &&

               // Address
               data.streetAddress is string && data.streetAddress.size() > 0 && data.streetAddress.size() <= 200 &&
               data.suburb is string && data.suburb.size() > 0 && data.suburb.size() <= 100 &&
               data.state in ['TAS', 'NSW', 'VIC', 'QLD', 'SA', 'WA', 'NT', 'ACT'] &&
               data.postcode is string && data.postcode.matches('^[0-9]{4}$') &&

               // Contact
               data.email is string && data.email.size() > 0 && data.email.size() <= 100 &&
               data.email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') &&
               data.phoneHome is string && data.phoneHome.size() <= 20 &&
               data.phoneWork is string && data.phoneWork.size() <= 20 &&
               data.phoneMobile is string && data.phoneMobile.size() <= 20 &&

               // Personal
               data.dateOfBirth is string && data.dateOfBirth.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&

               // Golf history (optional)
               data.previousClubs is string && data.previousClubs.size() <= 500 &&
               data.golfLinkNumber is string && data.golfLinkNumber.size() <= 50 &&
               data.lastHandicap is string && data.lastHandicap.size() <= 100 &&

               // Membership category (new format with category ID)
               data.membershipCategoryId is string && data.membershipCategoryId.size() > 0 && data.membershipCategoryId.size() <= 50 &&
               data.membershipCategoryName is string && data.membershipCategoryName.size() <= 100 &&

               // Status fields
               data.status == 'submitted' &&
               data.emailVerified == false &&

               // Metadata
               data.submittedFromIp is string && data.submittedFromIp.size() <= 50 &&
               data.userAgent is string && data.userAgent.size() <= 500 &&
               data.captchaScore is number && data.captchaScore >= 0.0 && data.captchaScore <= 1.0 &&
               data.captchaScore >= 0.5; // Minimum CAPTCHA score required
      }

      function hasRequiredApplicationFields(data) {
        return data.keys().hasAll([
          'title', 'fullName', 'streetAddress', 'suburb', 'state', 'postcode',
          'email', 'phoneHome', 'phoneWork', 'phoneMobile', 'dateOfBirth',
          'previousClubs', 'golfLinkNumber', 'lastHandicap',
          'membershipCategoryId', 'membershipCategoryName',
          'status', 'emailVerificationToken', 'emailVerificationExpiry',
          'emailVerified', 'verifiedAt', 'submittedFromIp', 'userAgent', 'captchaScore',
          'proposerName', 'seconderName', 'adminNotes'
        ]);
      }

      // Validate email verification update (PUBLIC UPDATE)
      function isValidEmailVerification(oldData, newData) {
        return // Status must change from submitted to email_verified
               oldData.status == 'submitted' &&
               newData.status == 'email_verified' &&
               // Email verified must change from false to true
               oldData.emailVerified == false &&
               newData.emailVerified == true;
               // Note: Field checking removed - serverTimestamp() causes issues with diff()
      }

      // Validate admin updates (AUTHENTICATED UPDATE)
      function isValidAdminUpdate(oldData, newData) {
        let allowedFields = ['status', 'approvedAt', 'rejectedAt', 'approvedBy',
                             'rejectedBy', 'rejectionReason', 'proposerName',
                             'seconderName', 'adminNotes', 'memberId', 'updatedAt'].toSet();

        return // Only specific fields can be changed
               newData.diff(oldData).affectedKeys().hasOnly(allowedFields) &&
               // Status changes must be valid
               isValidStatusChange(oldData.status, newData.status) &&
               // If approving, must set approvedBy with current user ID
               (newData.status != 'approved' || newData.approvedBy == request.auth.uid) &&
               // If rejecting, must set rejectedBy with current user ID and include reason
               (newData.status != 'rejected' ||
                (newData.rejectedBy == request.auth.uid &&
                 newData.rejectionReason is string &&
                 newData.rejectionReason.size() > 0));
      }

      function isValidStatusChange(oldStatus, newStatus) {
        return // email_verified -> approved
               (oldStatus == 'email_verified' && newStatus == 'approved') ||
               // email_verified -> rejected
               (oldStatus == 'email_verified' && newStatus == 'rejected') ||
               // No status change (updating other fields like proposer/seconder/notes)
               (oldStatus == newStatus);
      }
    }


    // ============================================
    // RECEIPT COUNTERS COLLECTION (INTERNAL)
    // ============================================

    match /receipt_counters/{year} {
      // Only EDIT role or higher can read counter (for display purposes)
      allow read: if canWrite();

      // Only EDIT role or higher can create/update counter
      // Counter is automatically created/updated during payment recording
      allow create, update: if canWrite() &&
                              isValidReceiptCounter(request.resource.data);

      // Never allow deletion of counter documents
      allow delete: if false;

      // Validate counter data structure
      // Note: updatedAt is optional and can be serverTimestamp
      function isValidReceiptCounter(data) {
        return data.lastNumber is number && data.lastNumber >= 0 &&
               (!('updatedAt' in data.keys()) || data.updatedAt is timestamp);
      }
    }


    // ============================================
    // DENY ALL OTHER COLLECTIONS
    // ============================================

    // Explicitly deny access to any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
